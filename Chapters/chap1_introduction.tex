%!TEX root = /Users/will/Documents/Academic/MA 470 -THESIS/THESIS/thesis.tex
\chapter{Introduction}
	Writing distributed systems are often held up as being some of the toughest problems that software engineers face today.  Managing threads, locks and synchronization, avoiding deadlocks and livelocks and dealing with failure and latency all contribute to distributed programming nightmarish reputation.  In the meantime, we steadily progress towards a future where all computation is distributed, where raw computing power is nothing more than a service that can be consumed like energy, and where huge systems sprawl across machines and networks to do their bidding.  
	
	Perhaps there is a better way.  Many computer scientists are now reevaluating the tools they use -- namely the languages -- in hopes that there may be a way to cut the gordian knot by making very low level changes.  The hope is that there is a breed of languages that offer a much more natural way to perform distributed computing, that do not have all the high-level nightmares that currently plague us.  The aim of this thesis is to explore what such a language might look like, and perhaps offer some concrete features with which we might judge the overall value of a candidate language.  
	
	
	For several decades theoretical computer scientists have been studying a branch of math known as \emph{processes algebras}.  The hope is to discover an algebraic model for computation that might eventually be the foundation for a new wave of programming languages that greatly ease the difficulty of distributed programming by considering computation via its natural distributed unit - the process.  A process can be a task of any size, but the important thing about it is that it shares no state with the processes in its environment.  Instead, processes interact via message passing -- sending data back-and-forth via named channels.  The idea is that my modeling computation in such terms, we might discover natural ways to solve distributed problems and not have to worry about the many headaches that would otherwise arise at a very high level in a language whose primitives are not built for a distributed setting.
			
	One of the most successful and influential process algebras to arise has be the \picalc, first given by Robin Milner, Joachim Parrow and David Walker.  It improved upon the process algebras that came before it by allowing processes a kind of mobility within their environments, which in turn allows for much more dynamic and powerful systems.  We will give a formal presentation of the \picalc, as a sort of starting point for our discussion of process algebra and the various languages they have inspired.  In addition, the presentation will give us some valuable tools and vocabulary for evaluating these languages.
	
	There has been a mushroom of process algebra that have sprung up around the \picalc, evidence of its fertility but also of the uncertainty of what the right system is.  We will look at a few of these variations at a somewhat higher level than the \picalc, and attempt to pull out some of the trends and major debates and clarify how they relate to the needs of distributed systems.  
	
	We will also look at a number of implementation of these languages, and use some example systems as a litmus test for now naturally they lend themselves to solving the problems.
