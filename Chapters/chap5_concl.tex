\chapter{Conclusions}
In the last chapter we surveyed Palamidessi's separation results, namely that no uniform encoding of the synchronous \picalc\ into the asynchronous \picalc\ that preserves a reasonable semantics exists.  
This is a very strong result.
Palamidessi's requirements of uniformity and reasonability both seem like natural properties of any language we'd like to consider.  
For this reason, the fully expressive synchronous \picalc\ seems like a better candidate for formal study than the asynchronous \picalc.

However, we need still consider the implementation of the \picalc.  
Asynchronous message passing is far easier to implement on distributed systems.  
Hence, it also seems useful to study the asynchronous \picalc\ since it models these systems more naturally than a synchronous model.
For the study of distributed systems in particular, rather than showing the asynchronous to be not worth our time, Palamidessi's separation result raises the question of whether we should be considering \emph{synchronous} calculi. 

Ideally, we'd like the best of both worlds.  The expressiveness of the synchronous \picalc\ allows us to solve a large class of problems much more easily and clearly.
We saw just how useful the synchronous \picalc\ can be for expressing systems in the mobile phone network example of Chapter \ref{Introduction}.
We could have modeled this system in the asynchronous \picalc, but it would have involved a convoluted mess of acknowledgement channels just to express the necessary ordering of events in the system.
Hence, in the last chapter we looked at some of the more implementation-minded encodings of the synchronous \picalc\ in the asynchronous \picalc.   
In the process, we saw the extent to which we need to relax Palamidessi's requirements to allow these encodings.

The creators of Pict, the Join-calculus, and other implementations based on the \picalc\ all decided to have their primitives support only asynchronous communication.
This greatly simplifies implementation, resulting in a cleaner, more efficient language.  
The summation operator in particular is difficult and expensive to fully implement.  
In the implementation of Pict, for example, David Turner notes \cite{turn96} that ``the additional costs imposed by summation are unacceptable.''  
Turner goes on to say that \emph{essential} uses of summation are infrequent in practice.
When summation is needed in Pict, it is made available by use of a library which implements summation using the asynchronous primitives of the Pict language.

Speaking in an interview on developing the \picalc, Robin Milner notes \cite{miln03}:
\begin{quote}
That was to me the challenge: picking communication primitives which could be understood at a reasonably high level as well as in the way these systems are implemented at a very low level...There's a subtle change from the Turing-like question of what are the fundamental, smallest sets of primitives that you can find to understand computation...as we move towards mobility... we are in a terrific tension between (a) finding a small set of primitives and (b) modeling the real world accurately.
\end{quote}
This tension is quite evident in the efforts of process algebraists to find the `right' calculus for modeling distributed systems.  The synchronous and asynchronous $\pi$-calculi are not the only process algebra that have been proposed.  Recently, the addition of \emph{locations} or \emph{domains} to \picalc-like languages has garnered considerable attention.  Intuitively, locations are sites for computation, which means that each process resides at a particular location.  In most of these algebras, processes can move from one location to another via \emph{migration}.  Some examples of location-enabled calculi are the $d\pi$-calculus of Hennessey \cite{henn07}, the Join-calculus \cite{fourn00} and the Nomadic Pict language \cite{wojci99}.  A broad and high-level overview of these and other calculi is given in \cite{cast02}.  Locations are a natural construct for distributed and mobile systems which are often implemented over several computational settings with computation constantly moving between them.  Locations are also helpful in the construction of languages focusing on efficiency, failure-tolerance and security since they enable a language to represent locations that differ in their resources, reliability and access privileges.  Locations are thus of great use for modeling distributed systems.  However, they would certainly not be numbered among the `smallest set of primitives' needed for computation.

We saw this same tension in our comparison of the synchronous and asynchronous $\pi$-calculi.  
Which calculus we choose as a model depends in part on our goals.
The synchronous \picalc\ is more elegant and fundamental, and is deserving of the continuing attention it has been given.
However, actual implementations must commit to asynchronous communication as their primitives.  
By limiting ourselves to the primitives of the asynchronous \picalc, we may yet discover useful new concepts and structures that solve the problems posed by distributed and mobile systems.  